<?php
/**
 * Copyright (c) 2017 Timo Ebel
 *
 * This work is licensed under the terms of the MIT license.
 * For a copy, see <https://opensource.org/licenses/MIT> or the LICENSE file included in this project.
 */

namespace Rekhyt\PhpDependencyChecker\Vulnerability\Repository\SLApi;

use GuzzleHttp\Client;
use GuzzleHttp\Exception\ClientException;
use GuzzleHttp\Exception\ServerException;
use Rekhyt\PhpDependencyChecker\Vulnerability\Entity\Advisory;
use Rekhyt\PhpDependencyChecker\Vulnerability\Repository\Provider\Vulnerability as VulnerabilityProvider;
use Rekhyt\PhpDependencyChecker\Vulnerability\ValueObject\AdvisoryTitle;
use Rekhyt\PhpDependencyChecker\Vulnerability\ValueObject\ApiEndpoint;
use Rekhyt\PhpDependencyChecker\Vulnerability\ValueObject\ComposerLockFileContent;
use Rekhyt\PhpDependencyChecker\Vulnerability\ValueObject\CVE;
use Rekhyt\PhpDependencyChecker\Vulnerability\ValueObject\PackageLink;
use Rekhyt\PhpDependencyChecker\Vulnerability\ValueObject\PackageName;
use Rekhyt\PhpDependencyChecker\Vulnerability\ValueObject\PackageVersion;

class Vulnerability implements VulnerabilityProvider
{
    /** @var Client */
    private $client;

    /** @var ApiEndpoint */
    private $apiEndpoint;

    /**
     * @param Client      $client
     * @param ApiEndpoint $apiEndpoint
     */
    public function __construct(Client $client, ApiEndpoint $apiEndpoint)
    {
        $this->client      = $client;
        $this->apiEndpoint = $apiEndpoint;
    }

    /** @inheritdoc */
    public function getAllByComposerLockFileContents(ComposerLockFileContent $lockFileContents)
    {
        try {
            $rawResponse = $this->client->request(
                'POST',
                $this->apiEndpoint->getValue(),
                [
                    'multipart' => [
                        [
                            'name'     => 'lock',
                            'contents' => $lockFileContents->getValue(),
                            'filename' => 'composer.lock',
                        ],
                    ],
                    'headers'   => [
                        'Accept' => 'application/json',
                    ],
                ]
            );
        } catch (ClientException $e) {
            throw new FetchingVulnerabilitiesFailedBadRequestException(
                'Error fetching vulnerabilities due to a bad request. Original message: ' . $e->getMessage(),
                400,
                $e
            );
        } catch (ServerException $e) {
            throw new FetchingVulnerabilitiesFailedServerErrorException(
                'Error fetching vulnerabilities due to a problem on the endpoint. Original message: ' . $e->getMessage(),
                500,
                $e
            );
        }

        $response = @json_decode($rawResponse->getBody()->getContents(), true);

        if (null === $response || !is_array($response)) {
            throw new FetchingVulnerabilitiesFailedInvalidResponseBody(
                'Cannot parse response body.',
                550,
                $rawResponse->getBody()
            );
        }

        $vulnerabilities = [];
        foreach ($response as $packageName => $packageInformation) {
            $advisories = [];
            foreach ($packageInformation['advisories'] as $advisory) {
                $advisories[] = new Advisory(
                    new AdvisoryTitle($advisory['title']),
                    new PackageLink($advisory['link']),
                    new CVE($advisory['cve'])
                );
            }

            $vulnerabilities[] = new \Rekhyt\PhpDependencyChecker\Vulnerability\Entity\Vulnerability(
                new PackageName($packageName),
                new PackageVersion($packageInformation['version']),
                $advisories
            );
        }

        return $vulnerabilities;
    }
}